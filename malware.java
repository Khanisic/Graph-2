// Time Complexity : O(v+e)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No


class Solution {
    int[] colors;
    int color;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0) {
            return 0;
        }
        int n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1) {
                dfs(graph, i);
                color++;
            }
        }
        int[] groups = new int[color];
        for (int i = 0; i < n; i++) {
            int index = colors[i];
            groups[index]++;
        }
        int[] infected = new int[color];
        for (int i = 0; i < initial.length; i++) {
            int currColor = colors[initial[i]];
            infected[currColor]++;
        }
        int answer = -1;
        for (int i = 0; i < initial.length; i++) {
            int currColor = colors[initial[i]];
            if (infected[currColor] == 1) {
                if (answer == -1) {
                    answer = initial[i];
                } else if (groups[currColor] > groups[colors[answer]]) {
                    answer = initial[i];
                } else if (groups[currColor] == groups[colors[answer]] && answer > initial[i]) {
                    answer = initial[i];
                }
            }
        }
        if (answer == -1) {
            int min = Integer.MAX_VALUE;
            for (int i = 0; i < initial.length; i++) {
                min = Math.min(min, initial[i]);
            }
            return min;
        }
        return answer;
    }

    private void dfs(int[][] graph, int v) {
        if (colors[v] != -1) {
            return;
        }
        colors[v] = color;
        for (int i = 0; i < graph.length; i++) {
            if (graph[v][i] == 1) {
                dfs(graph, i);
            }
        }
    }
}